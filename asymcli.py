# input_file_0.py (Client)

# Импортируем необходимые модули.
import socket # Модуль для работы с сетевыми сокетами (для создания сетевых соединений).
import threading # Модуль для работы с потоками (позволяет выполнять несколько задач параллельно).
from Crypto.PublicKey import RSA # Модуль для генерации и работы с RSA-ключами (асимметричное шифрование).
from Crypto.Cipher import PKCS1_OAEP, AES # Модули для различных алгоритмов шифрования:
                                          # PKCS1_OAEP - для RSA-шифрования (обычно используется для шифрования сессионных ключей).
                                          # AES - для Advanced Encryption Standard (симметричное шифрование данных).
from Crypto.Random import get_random_bytes # Модуль для генерации криптографически стойких случайных байтов (например, для сессионных ключей и nonce).

# Определяем константы для сетевого подключения.
HOST = '127.0.0.1' # IP-адрес сервера (в данном случае, "localhost" - означает, что сервер находится на том же компьютере).
PORT = 9090        # Порт, на котором будет слушать сервер (должен совпадать с портом сервера).

# Глобальная переменная для управления состоянием клиента.
# Используется, чтобы контролировать, работает ли клиентский поток приема сообщений.
client_running = True

def receive_messages(sock, private_key, server_public_key):
    """
    Функция для приема и расшифровки сообщений от сервера в отдельном потоке.
    
    Аргументы:
        sock (socket.socket): Объект сокета, используемый для связи с сервером.
        private_key (Crypto.PublicKey.RSA._RSAobj): Приватный RSA-ключ клиента,
                                                    используется для расшифровки сессионных ключей,
                                                    зашифрованных сервером с помощью публичного ключа клиента.
        server_public_key (Crypto.PublicKey.RSA._RSAobj): Публичный RSA-ключ сервера (не используется напрямую в этой функции,
                                                          но добавлен для единообразия, если бы он был нужен для чего-то другого).
    """
    global client_running # Объявляем, что мы используем глобальную переменную client_running.
    try:
        while client_running: # Цикл будет продолжаться, пока клиент работает.
            try:
                # 1. Получение размера зашифрованного сессионного ключа (4 байта).
                key_size_bytes = sock.recv(4)
                if not key_size_bytes: # Если получены пустые данные, это означает, что сервер отключился.
                    print("\nСервер закрыл соединение (получены пустые данные размера ключа).")
                    break # Выходим из цикла.
                key_size = int.from_bytes(key_size_bytes, 'big') # Преобразуем байты размера в целое число (big-endian порядок байтов).

                # 2. Получение самого зашифрованного сессионного ключа.
                encrypted_key = sock.recv(key_size)
                if not encrypted_key: # Снова проверяем на отключение сервера.
                    print("\nСервер закрыл соединение (получены пустые данные зашифрованного ключа).")
                    break

                # 3. Получение размера зашифрованного сообщения (4 байта).
                msg_size_bytes = sock.recv(4)
                if not msg_size_bytes: # Проверка на отключение сервера.
                    print("\nСервер закрыл соединение (получены пустые данные размера сообщения).")
                    break
                msg_size = int.from_bytes(msg_size_bytes, 'big') # Преобразуем байты размера в целое число.

                # 4. Получение самого зашифрованного сообщения.
                encrypted_msg = sock.recv(msg_size)
                if not encrypted_msg: # Проверка на отключение сервера.
                    print("\nСервер закрыл соединение (получены пустые данные зашифрованного сообщения).")
                    break

                # 5. Расшифровка сессионного ключа с использованием приватного RSA-ключа клиента.
                # Сессионный ключ был зашифрован сервером с помощью публичного RSA-ключа клиента.
                cipher_rsa = PKCS1_OAEP.new(private_key) # Создаем объект для RSA-расшифровки.
                session_key = cipher_rsa.decrypt(encrypted_key) # Расшифровываем сессионный ключ.

                # 6. Разделение зашифрованного сообщения на части: Nonce, Шифротекст, Тег.
                # Nonce (Initialization Vector) - одноразовый уникальный номер, используется для обеспечения уникальности шифротекста
                # даже при шифровании одинаковых сообщений одним и тем же ключом. В AES GCM/EAX он обычно 16 байт.
                nonce = encrypted_msg[:16] # Первые 16 байт - это Nonce.
                ciphertext = encrypted_msg[16:-16] # Шифротекст - это данные между Nonce и Тегом.
                tag = encrypted_msg[-16:]          # Тег (Authentication Tag) - последние 16 байт, используется для проверки целостности
                                                  # и подлинности сообщения (что оно не было изменено и пришло от отправителя).
                
                # 7. Расшифровка самого сообщения с использованием AES в режиме EAX (Authenticated Encryption with Associated Data).
                # EAX обеспечивает как конфиденциальность (шифрование), так и целостность/аутентификацию.
                cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce=nonce) # Создаем объект AES для расшифровки с сессионным ключом и Nonce.
                # Используем decrypt_and_verify для проверки тега и расшифровки.
                # Если тег не совпадает (сообщение было изменено или ключ неверный), будет выброшено исключение ValueError.
                decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)

                # 8. Выводим расшифрованное сообщение.
                print(f"\nСообщение от сервера: {decrypted.decode()}") # Декодируем байты в строку (UTF-8 по умолчанию).
                # Выводим подсказку для пользователя, чтобы он мог продолжать вводить сообщения,
                # не перебивая вывод принятого сообщения. flush=True гарантирует немедленный вывод.
                print("Введите сообщение (exit для выхода): ", end='', flush=True)

            except ValueError as ve: # Это исключение ловится, если RSA-расшифровка не удалась,
                                     # или если тег AES-сообщения не прошел проверку (сообщение повреждено/подделано).
                print(f"\nОшибка верификации/дешифрования сообщения от сервера: {ve}")
                client_running = False # В случае такой ошибки, клиент прекращает работу.
                break
            except (ConnectionResetError, BrokenPipeError) as e: # Ловим ошибки, связанные с разрывом соединения.
                print(f"\nСоединение с сервером разорвано: {e}")
                client_running = False
                break
            except OSError as oe: # Ловим общие ошибки операционной системы, связанные с сокетами (например, "Bad file descriptor").
                print(f"\nОшибка сокета при получении сообщений от сервера: {oe}")
                client_running = False
                break
            except Exception as e: # Ловим любые другие непредвиденные ошибки.
                print(f"\nНеизвестная ошибка при получении сообщений: {e}")
                client_running = False
                break
    except Exception: # Общий блок catch для внешнего try, если что-то пойдет не так при запуске потока.
        pass # Просто пропускаем, так как внутренние исключения уже обрабатываются.
    finally:
        client_running = False # Убеждаемся, что флаг client_running установлен в False при выходе из функции. 

def main():
    """
    Главная функция, управляющая логикой клиента:
    - Генерация ключей.
    - Подключение к серверу.
    - Обмен публичными ключами.
    - Запуск потока для приема сообщений.
    - Цикл для отправки сообщений.
    - Корректное завершение работы.
    """
    global client_running # Объявляем, что будем использовать глобальную переменную client_running.
    
    # 1. Генерация пары RSA-ключей для клиента.
    # 2048 бит - это стандартная безопасная длина для RSA-ключей.
    private_key = RSA.generate(2048) # Приватный ключ - держится в секрете.
    public_key = private_key.publickey() # Публичный ключ - может быть передан кому угодно.

    sock = socket.socket() # Создаем объект сокета. По умолчанию AF_INET (IPv4) и SOCK_STREAM (TCP).
    try:
        # 2. Попытка подключения к серверу.
        sock.connect((HOST, PORT)) # Устанавливаем TCP-соединение с сервером по указанным IP и порту.
        print(f"Подключено к серверу {HOST}:{PORT}")

        # 3. Обмен публичными ключами между клиентом и сервером.
        # Клиент отправляет свой публичный ключ серверу.
        sock.sendall(public_key.export_key()) # Отправляем публичный ключ клиента в байтовом формате.

        # Клиент получает публичный ключ сервера.
        server_public_key_data = sock.recv(1024) # Принимаем до 1024 байт данных публичного ключа сервера.
        if not server_public_key_data: # Проверяем, что данные получены.
            print("Сервер отключился до получения его публичного ключа.")
            return # Если нет, выходим.
        server_public_key = RSA.import_key(server_public_key_data) # Импортируем полученные байты как RSA-ключ.
        print("Обмен ключами выполнен успешно")

        # 4. Запуск отдельного потока для приема сообщений от сервера.
        # Это позволяет клиенту одновременно отправлять сообщения (через ввод пользователя)
        # и принимать сообщения от сервера без блокировки.
        receive_thread = threading.Thread(
            target=receive_messages, # Функция, которая будет выполняться в новом потоке.
            args=(sock, private_key, server_public_key) # Аргументы, передаваемые функции.
        )
        receive_thread.daemon = True # Установка потока как "демона" означает, что он завершится автоматически,
                                     # когда завершится основной поток программы.
        receive_thread.start() # Запускаем поток.

        # 5. Цикл для отправки сообщений серверу.
        while client_running: # Продолжаем, пока клиент активен (флаг client_running True).
            message = input("Введите сообщение (exit для выхода): ") # Просим пользователя ввести сообщение.
            if message.lower() == "exit": # Если пользователь ввел "exit", выходим из цикла.
                break

            # 6. Шифрование сообщения перед отправкой серверу.
            # Для каждого сообщения генерируется новый сессионный AES-ключ.
            # Этот AES-ключ шифруется публичным RSA-ключом сервера и отправляется вместе с зашифрованным сообщением.
            session_key = get_random_bytes(16) # Генерируем случайный 16-байтовый сессионный ключ для AES.
            cipher_rsa = PKCS1_OAEP.new(server_public_key) # Создаем объект для RSA-шифрования, используя публичный ключ сервера.
            encrypted_key = cipher_rsa.encrypt(session_key) # Шифруем сессионный ключ публичным ключом сервера.

            # Шифруем само сообщение с использованием сессионного AES-ключа.
            cipher_aes = AES.new(session_key, AES.MODE_EAX) # Создаем объект AES с сессионным ключом в режиме EAX.
            ciphertext, tag = cipher_aes.encrypt_and_digest(message.encode()) # Шифруем сообщение (преобразуем в байты) и получаем тег.
            data = cipher_aes.nonce + ciphertext + tag # Объединяем Nonce, Шифротекст и Тег в один пакет данных.

            try:
                # 7. Отправка зашифрованного сессионного ключа и сообщения серверу.
                # Сначала отправляем размер зашифрованного ключа (4 байта).
                sock.sendall(len(encrypted_key).to_bytes(4, 'big'))
                # Затем сам зашифрованный ключ.
                sock.sendall(encrypted_key)
                # Затем размер зашифрованного сообщения (4 байта).
                sock.sendall(len(data).to_bytes(4, 'big'))
                # Затем само зашифрованное сообщение (Nonce + Ciphertext + Tag).
                sock.sendall(data)
            except (BrokenPipeError, ConnectionResetError, OSError) as e: # Ловим ошибки, если соединение было разорвано во время отправки.
                print(f"Ошибка сокета при отправке сообщения: {e}")
                break # Выходим из цикла отправки.
            except Exception as e: # Ловим любые другие непредвиденные ошибки при отправке.
                print(f"Ошибка при отправке сообщения: {e}")
                break

    except ConnectionRefusedError: # Ловим ошибку, если сервер не запущен или отказал в подключении.
        print(f"Не удалось подключиться к серверу {HOST}:{PORT}")
    except Exception as e: # Ловим любые другие непредвиденные ошибки во время инициализации или обмена ключами.
        print(f"Ошибка: {e}")
    finally:
        client_running = False # Убеждаемся, что флаг client_running установлен в False.
        print("Завершение работы клиента...")
        try:
            # Пытаемся корректно закрыть сокет.
            # sock.fileno() != -1 проверяет, что сокет еще открыт.
            if sock and sock.fileno() != -1: 
                sock.shutdown(socket.SHUT_RDWR) # Закрываем соединение на чтение и запись.
                sock.close() # Закрываем сокет.
        except OSError as e:
            print(f"Ошибка при закрытии сокета клиента в finally: {e} (Возможно, сокет уже был закрыт).")
        except Exception as e:
            print(f"Ошибка при закрытии сокета: {e}")
        print("Клиент остановлен")

# Точка входа в программу.
if __name__ == "__main__":
    main() # Вызываем главную функцию при запуске скрипта.