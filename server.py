import socket  # Импорт модуля для работы с сетевыми сокетами (для создания сетевых соединений)
import pickle  # Импорт модуля pickle для сериализации/десериализации объектов Python (для преобразования объектов в байты и обратно)

HOST = '127.0.0.1'  # IP-адрес хоста, на котором будет слушать сервер (localhost - ваш компьютер)
PORT = 9090       # Порт, на котором будет слушать сервер (число от 1024 до 65535)

# --- Инициализация сервера ---

# 1. Создание сокета:
# socket.AF_INET указывает, что мы используем сетевой протокол IPv4.
# socket.SOCK_STREAM указывает, что мы используем протокол TCP (для потоковой передачи данных, надежное соединение).
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 2. Привязка сокета к адресу и порту:
# Сервер начинает "слушать" (ожидать подключений) на указанном IP-адресе и порту.
server_socket.bind((HOST, PORT))

# 3. Перевод сокета в режим ожидания входящих подключений:
# 1 - это максимальное количество клиентов, которые могут находиться в очереди на подключение,
# пока сервер обрабатывает текущее соединение.
server_socket.listen(1)
print(f"Сервер запущен и слушает на {HOST}:{PORT}...")

# 4. Принятие входящего соединения:
# server_socket.accept() блокирует выполнение программы до тех пор, пока клиент не подключится.
# conn - это новый сокет, который будет использоваться для обмена данными именно с этим подключившимся клиентом.
# addr - это адрес (IP-адрес и порт) подключившегося клиента.
conn, addr = server_socket.accept()
print(f"Подключен клиент с адреса: {addr}")

# --- Обмен ключами Диффи-Хеллмана ---

# 5. Получение первого сообщения от клиента:
# conn.recv(1024) принимает до 1024 байт данных от клиента.
# Ожидается, что клиент отправит кортеж (p, g, A), где:
# p - большое простое число (публичный параметр)
# g - генератор по модулю p (публичный параметр)
# A - открытый ключ клиента (A = g^a mod p)
client_data_bytes = conn.recv(1024)
# pickle.loads() десериализует полученные байты обратно в Python объекты.
p, g, A = pickle.loads(client_data_bytes)
print(f"Получены публичные параметры и открытый ключ от клиента:")
print(f"  p (модуль): {p}")
print(f"  g (генератор): {g}")
print(f"  A (открытый ключ клиента): {A}")

# 6. Определение секретного числа сервера (b):
# Это ПРИВАТНОЕ число сервера, оно должно быть большим и случайным в реальных сценариях.
# В данном примере используется фиксированное маленькое значение для демонстрации.
b = 9
print(f"Секретное число сервера (b): {b}")

# 7. Вычисление открытого ключа сервера (B):
# B = g^b mod p.
# pow(base, exp, mod) - это встроенная функция Python для эффективного вычисления (base^exp) % mod.
B = pow(g, b, p)
print(f"Вычислен открытый ключ сервера (B): {B}")

# 8. Отправка открытого ключа B клиенту:
# pickle.dumps(B) сериализует число B в байты для отправки по сети.
conn.send(pickle.dumps(B))
print(f"Отправлен открытый ключ B клиенту.")

# 9. Вычисление общего секретного ключа (K) на сервере:
# K = A^b mod p.
# Здесь A - это открытый ключ, полученный от клиента.
# Этот K должен совпасть с K, вычисленным на клиенте.
shared_secret_key_server = pow(A, b, p)
print(f"Вычислен общий секретный ключ на сервере (K): {shared_secret_key_server}")

# --- Завершение работы ---

# 10. Закрытие соединения с клиентом:
conn.close()
# 11. Закрытие серверного сокета:
server_socket.close()
print("Соединение закрыто. Сервер остановлен.")